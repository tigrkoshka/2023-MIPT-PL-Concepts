\hypertarget{cmd:calls}{
    \subsubsection{Function calls}
}

\cmdtable{Function call comands}{

    \hline

    50 & \St{call} & \Ss{RR} & \RRcmd{call}{r0}{r5}{2} &
    Call the function located \newline
    at the address \St{$\text{r5} + \text{2}$} \\

    \hline

    51 & \St{calli} & \Ss{J} & \St{calli\kern 0.5em 21913} &
    Call the function located \newline
    at the address \St{21913} \\

    \hline

    52 & \St{ret} & \Ss{J} & \St{ret\kern 0.35em 3} &
    Return and clear \St{3} arguments \\

}

\vspace{0.5cm}

This section defines the rules by which the execution of one part of the code
(the \textit{caller}) can be delayed until another part (the \textit{callee})
is executed.
The callee is often also referred to as a \textit{subprogram} or
a \textit{function}, and the delay process is called a \textit{function call}.
The function call commands extensively use the \St{r15} register.
Its usage is described below.

\vspace{-0.35cm}

\paragraph{\St{r15} register}\

The \St{r15} register \textit{always} contains the address of the next
instruction to be executed.
When executing the binary code, the \St{Karma} executor consecutively checks
the \St{r15} register and executes the command, whose address is stored there.
If at any point the \St{r15} register is corrupted and does not store
a valid memory address
(i.e.\ if the value stored in the \St{r15} register is greater or equal
to $2^{20}$), an execution error occurs.

\vspace{-0.35cm}

\paragraph{Calling convention}\

For the functions to be meaningful they need to accept \textit{arguments},
i.e.\ values passed from the caller to the callee for the latter to perform
computations dependant on these values.
The arguments can be passed in a number of ways, e.g.\ be saved to some
predefined registers or a preallocated part of the address space to then
be retrieved from there by the caller.
Alternatively, the arguments may be passed via the stack.
For all programs to be understandable and intuitive to a code reader,
some sort of agreement has to be established.
This agreement is often called the \textit{calling convention}.

Note that a calling convention is exactly that -- a convention.
Nothing on the architecture or the syntax level prevents one from not following
it during their code development.
However, that is considered a bad practice as it can lead to confusion and
unexpected results for the code user.

By the \St{Karma} assembler calling convention, the arguments are passed to
a function via the stack last-to-first, that is, the semantically first argument
is the last one to be pushed to the stack.

\vspace{-0.35cm}

\paragraph{\St{call}, \St{calli}}\

These commands perform the transfer of control from the caller to the callee.

For the \St{call} command the address of the next instruction to be executed
is obtained from the specified operands in the {\hyperlink{types:twos_complement}
{common manner}.
If this value does not represent a valid address,
i.e.\ is greater or equal to $2^{20}$, an execution error occurs.

For the \St{calli} command the address of the next instruction to be executed
is specified by the 20-bit \textit{unsigned} memory address operand.
Since any 20-bit unsigned value represents a valid memory address, no execution
error can occur in this case.

Both these command do the following:

\begin{itemize}
    \item Push the value obtained from the \St{r15} register (i.e.\ the address
    of the instruction that would be executed next if the current command
    did not interrupt the consecutive execution, the \textit{return point})
    to the stack (as if with the \hyperlink{cmd:push}{\St{push}} command)
    
    \item Store the address obtained by the operands (as described above) in
    the \St{r15} register (to be executed next)
\end{itemize}

The \St{call} command additionally stores a copy of the return point address
into the provided receiver register.

\vspace{-0.35cm}

\paragraph{\St{ret}}\

This command performs the transfer of control from the callee back to the caller.
It pops a value from the stack into the \St{r15} register (as if with
the \hyperlink{cmd:pop}{\St{pop}} command),
after which it increments the value stored in \St{r14} (the stack head pointer)
by a value specified by its operand.

This is the only \Ss{J} command, for which the memory address operand does
\textbf{not} in fact represent a memory cell.
Instead, it specifies the number of additional (to the return point address)
values that should be popped from the stack (without storing them anywhere).
It is used to clear the stack from the function arguments.
It is the user's responsibility to make sure that the number of additional
values popped from the stack equals the number of the function arguments,
i.e.\ the executor has no way of checking that condition, and specifying
the wrong value as the \St{ret} command operand may lead to unexpected stack
contents.
