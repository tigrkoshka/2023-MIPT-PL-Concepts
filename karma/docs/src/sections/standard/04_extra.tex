\subsection{Further specifications}

\subsubsection{Labels}

Either before a command or on a separate line one may place a \textit{label}, which can be used later on in the assembler code to indicate the address of the command it is placed before.

Syntax:

\begin{itemize}
    \item A label must consist only of lowercase latin letters and/or digits and not start with a digit
    \item A label must be followed by a colon
    \item A label must be the first word in its line (it may be the only word of the line)
    \item A label must not conflict with predefined words (i.e.\ command names, directives, etc.)
    \item The labels must be unique (i.e. label redefinition is not allowed)
\end{itemize}

Usage:

\begin{itemize}
    \item A label usage may precede its definition
    \item A label must be defined somewhere in the code to be used, there are no predefined labels
    \item A label may only be used as a memory address, i.e.\ only in command of either \Ss{RM} or \Ss{J} type\\
    Note: this means that, when used, a label is always the last word in its line (see \hyperlink{command:formats}{command formats})
\end{itemize}

\subsubsection{\St{End} directive}

An assembler program must have \textit{exactly one} \St{end} directive, which must be in \textit{the last} line of the program.
It has one operand which indicates the address of the first instruction (or a label).

\subsubsection{Comments}

Each line may contain a semicolon.
If it does, everything after the semicolon is considered a comment and is not compiled into the executable file.
Multiline comments are not allowed.

\vspace{.4in}

\subsection{Notes}

\begin{itemize}
    \item The \St{Karma} processor has a RISC architecture, which means that there is no way to operate directly on memory cells, all data has to be loaded to the registers before modifications and the results have to be explicitly stored back to the memory if necessary
    \item A function call does not include the function arguments.
    They can be passed either via the stack or via the registers (by a programmer-defined convention).
    However, if a function is directly or indirectly recursive, the best practice is to pass the arguments via the stack
    \item A Von Neumann architecture of the \St{Karma} computer implies that both the machine code of the program and the stack are inside the global address space.
    The machine code is placed at its beginning, while the stack starts at its end and grows `backwards'
    \item The stack does not have any size limits besides the address space size
    \item Our system allows to write data to any memory cells, including the ones occupied by the machine code itself.
    Therefore, theoretically, a program might overwrite itself during runtime, although such behaviour is not considered a good practice
\end{itemize}
