\section{\St{Karma} processor description}

\subsection{\St{Karma} processor command set}

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table}[h!]
        \centering
        \caption{\St{Karma} processor commands description}
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}
            \hline

            Code & Name & Format & Description \\

            \hline

            0 & \St{halt} & \Ss{RI} &

            Stop processor \newline
            \St{halt r1 0} \\

            \hline

            \hypertarget{syscall}{} 1 & \St{syscall} & \Ss{RI} &

            System call (see \hyperlink{syscall:details}{here} for details) \newline
            \St{syscall r0, 100} \\

            \hline

            2 & \St{add} & \Ss{RR} &

            Registers addition \newline
            The value in the source register modified by the immediate operand \newline
            is added to the value in the receiver register \newline
            \St{add r1, r2, 3} \newline
            In the example above \St{r2+3} is added to \St{r1} \\

            \hline
            3 & \St{addi} & \Ss{RI} &

            Immediate operand addition to register \newline
            The immediate operand is added to the value in the receiver register \newline
            \St{addi r4, 10} \\

            \hline

            4 & \St{sub} & \Ss{RR} &

            Registers subtraction \newline
            The value in the source register modified by the immediate operand \newline
            is subtracted from the value in the receiver register \newline
            \St{sub r3, r5, 5}
            \newline In the example above \St{r5+5} is subtracted from \St{r3} \\

            \hline

            5 & \St{subi} & \Ss{RI} &

            Immediate operand subtraction from register \newline
            The immediate operand is subtracted from the value in the receiver register \newline
            \St{subi r4, 1} \\

            \hline

            6 & \St{mul} & \Ss{RR} &

            Registers multiplication \newline
            The value in the receiver register is multiplied by the value in the source \newline
            register modified by the immediate operand \newline
            The result is placed in a pair of registers starting from the receiver \newline
            so that the receiver contains the lower 32 bits of the result \newline
            \St{mul r3, r10, 2} \newline
            In the example above \St{r3} is multiplied by \St{r10+2} and the result \newline
            is placed in \St{r3} (low 32 bits) and \St{r4} (high 32 bits) \\

            \hline

            7 & \St{muli} & \Ss{RI} &

            Register multiplication by immediate operand \newline
            The value in the receiver register is multiplied by the immediate operand \newline
            The result is placed in a pair of registers starting from the receiver \newline
            so that the receiver contains the lower 32 bits of the result \newline
            \St{muli r5, 100} \newline
            In the example above the low 32 bits of the result will be in \St{r5} \newline
            and the high 32 bits -- in \St{r6} \\

            \hline

            8 & \St{div} & \Ss{RR} &

            Registers division \newline
            The low 32 bits of the dividend are located in the receiver register, \newline
            the high 32 bits -- in the next register.
            The divisor is located in the source \newline
            register and is modified by the immediate operand \newline
            The quotient is placed in the receiver register (if it does not fit, a `quotient \newline
            overflow' runtime error occurs) and the remainder -- in the next register \newline
            \St{div r3, r10, 5} \newline
            After execution of the example above \St{r3} will contain the quotient of dividing \newline
            \St{(r3,r4)} by \St{r10+5} and \St{r4} will contain the remainder \\

            \hline

            9 & \St{divi} & \Ss{RI} &

            Register division by immediate operand \newline
            The dividend and the result locations are analogous to \St{div} operation \newline
            \St{divi r3, 10} \newline
            After execution of the example above \St{r3} will contain the quotient of dividing \newline
            \St{(r3,r4)} by \St{10} and \St{r4} will contain the remainder \\

            \hline

        \end{tabular}
    \end{table}
}

\newpage

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table*}[h!]
        \centering
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

            \hline

            12 & \St{lc} & \Ss{RI} &

            Storing immediate operand to the register \newline
            Supplemental bitwise shift and addition commands are required for storing \newline
            constants greater than $2^{20} - 1$ \newline
            \St{lc r7, 123} \\

            \hline

            13 & \St{shl} & \Ss{RR} &

            Bitwise left-shift of the value in the receiver register by the value \newline
            in the source register modified by the immediate operand \newline
            \St{shl r1, r2, 1} \\

            \hline

            14 & \St{shli} & \Ss{RI} &

            Bitwise left-shift of the value in the receiver register by \newline
            the immediate operand \newline
            \St{shli r1, 2} \\

            \hline

            15 & \St{shr} & \Ss{RR} &

            Bitwise right-shift of the value in the receiver register by the value \newline
            in the source register modified by the immediate operand \newline
            \St{shr r1, r2, 1} \\

            \hline

            16 & \St{shri} & \Ss{RI} &

            Bitwise right-shift of the value in the receiver register by \newline
            the immediate operand \newline
            \St{shri r1, 2} \\

            \hline

            17 & \St{and} & \Ss{RR} &

            Bitwise \textbf{and} of the value in the receiver register by the value \newline
            in the source register modified by the immediate operand \newline
            \St{and r4, r6, 5} \\

            \hline

            18 & \St{andi} & \Ss{RI} &

            Bitwise \textbf{and} of the value in the receiver register by the immediate operand \newline
            \St{andi r5, 2} \\

            \hline

            19 & \St{or} & \Ss{RR} &

            Bitwise \textbf{or} of the value in the receiver register by the value \newline
            in the source register modified by the immediate operand \newline
            \St{or r3, r2, 2} \\

            \hline

            20 & \St{ori} & \Ss{RI} &

            Bitwise \textbf{or} of the value in the receiver register by the immediate operand \newline
            \St{ori r6, 100} \\

            \hline

            21 & \St{xor} & \Ss{RR} &

            Bitwise \textbf{xor} of the value in the receiver register by the value \newline
            in the source register modified by the immediate operand \newline
            \St{xor r1, r5, 0} \\

            \hline

            22 & \St{xori} & \Ss{RI} &

            Bitwise \textbf{xor} of the value in the receiver register by the immediate operand \newline
            \St{xori r1, 127} \\

            \hline

            23 & \St{not} & \Ss{RI} &

            Bitwise \textbf{not} of the value in the receiver register \newline
            The immediate value is ignored, but per our agreement must be present \newline
            for the simplicity of the compiler \newline
            \St{not r1, 0} \\

            \hline

            24 & \St{mov} & \Ss{RR} &

            Forwarding the value in the source register modified by the immediate \newline
            operand to the receiver register \newline
            \St{mov r0, r3, 10} \newline
            After the execution of the example above \St{r3+10} is stored in \St{r0} \\

            \hline

        \end{tabular}
    \end{table*}
}

\newpage

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table*}[h!]
        \centering
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

            \hline

            \hypertarget{addd}{} 32 & \St{addd} & \Ss{RR} &

            Real-valued registers addition \newline
            The floating-point values are stored in two registers, the provided registers \newline
            contain the lower bits of the values (see \hyperlink{float:storage}{here} for details) \newline
            The immediate operand modifies the lower bits of the floating-point \newline
            representation of the source value, not the value itself, \newline
            so it should be used with much caution \newline
            \St{addd r2, r5, 0} \newline
            In the example above a floating-point value stored in \St{(r5,r6})\newline
            is added to the one stored in \St{(r2,r3}) \\

            \hline

            33 & \St{subd} & \Ss{RR} &

            Real-valued registers subtraction \newline
            For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
            \St{subd r1, r6, 0} \newline
            In the example above a floating-point value stored in \St{(r6,r7})\newline
            is subtracted from the one stored in \St{(r1,r2}) \\

            \hline

            34 & \St{muld} & \Ss{RR} &

            Real-valued registers multiplication \newline
            For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
            \St{muld r0, r2, 0} \newline
            In the example above a floating-point value stored in \St{(r0,r1})\newline
            is multiplied by the one stored in \St{(r2,r3}) \\

            \hline

            35 & \St{divd} & \Ss{RR} &

            Real-valued registers division \newline
            For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
            \St{divd r1, r3, 0} \newline
            In the example above a floating-point value stored in \St{(r1,r2})\newline
            is divided by the one stored in \St{(r3,r4}) \\

            \hline

            36 & \St{itod} & \Ss{RR} &

            Integer to floating-point transformation \newline
            The value in the source register modified by the immediate operand \newline
            is interpreted as an integer, transformed to a floating-point value and \newline
            stored in two registers starting from the receiver so that the receiver \newline
            contains the lower bits of the result \newline
            \St{itod r2, r5, 5} \newline
            In the example above the floating-point representation of value \St{r5+5} \newline
            is stored to \St{(r2,r3)} with \St{r2} containing the low 32 bits of the result \\

            \hline

            37 & \St{dtoi} & \Ss{RR} &

            Floating-point to integer transformation \newline
            The real value specified by the source register is rounded down \newline
            to the closest integer \newline
            For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
            If the resulting value does not fit a register, an error occurs \newline
            \St{dtoi r2, r5, 0} \newline
            In the example above the floating-point value stored in \St{(r5,r6)} \newline
            is rounded down and stored in \St{r2} \\

            \hline

        \end{tabular}
    \end{table*}
}

\newpage

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table*}[h!]
        \centering
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

            \hline

            38 & \St{push} & \Ss{RI} &

            Push the value from the source register modified by the immediate operand \newline
            to the stack (and then move the stack pointer) \newline
            \St{push r0, 255} \newline
            In the example above the value \St{r0+255} is stored to the address from \St{r14}, \newline
            after which the stack pointer (\St{r14}) is decremented by 1 \\

            \hline

            39 & \St{pop} & \Ss{RI} &

            Pop the value from the stack and store it in the receiver register after \newline
            modifying by the immediate operand (after moving the stack pointer) \newline
            \St{pop r3, 3} \newline
            In the example above the stack pointer (\St{r14}) is incremented by 1, \newline
            after which the value stored by the address from \St{r14} is incremented by \St{3} \newline
            and stored in \St{r3} \\

            \hline

            40 & \St{call} & \Ss{RR} &

            Call the function, the address of which can be acquired by modifying \newline
            the source register by the immediate operand \newline
            The address of the command following the current one is stored \newline
            in the receiver register \newline
            \St{call r0, r5, 2} \newline
            In the example above the function stored by the address \St{r5+2} is called and \newline
            the address of the command following the current one is both pushed to the \newline
            stack (i.e.\ stored by the address from \St{r14} with a consequent decrement of \newline
            \St{r14}) and stored in \St{r0} \\

            \hline

            41 & \St{calli} & \Ss{J} &

            Call the function, the address of which is specified by the immediate operand \newline
            \St{calli 13323} \newline
            In the example above the function stored by the address \St{13323} is called \newline
            and the address of the command following the current one is pushed to \newline
            the stack (i.e.\ stored by the address from \St{r14} with a consequent \newline
            decrement of \St{r14}) \\

            \hline

            42 & \St{ret} & \Ss{J} &

            Return from function to caller \newline
            The address of the next executed instruction is popped from the stack \newline
            The immediate operand specifies the number of additional words that should \newline
            be ejected from the stack (by simply incrementing the \St{r14} pointer) before \newline
            popping the next executed instruction address (it must equal the number \newline
            of the function arguments) \newline
            \St{ret 3} \newline
            In the example above the pointer from \St{r14} is incremented by $3 + 1 = 4$, \newline
            after which the next executed instruction address is acquired by the address \newline
            from \St{r14} \\

            \hline

            43 & \St{cmp} & \Ss{RR} &

            Registers comparison \newline
            The value in the receiver register is compared to the value in the source \newline
            pointer modified by the immediate operand and the result is stored \newline
            to the \St{flags} register \newline
            \St{cmp r0, r1, 2} \newline
            In the example above \St{r0} is compared to \St{r1+2} \\

            \hline

            44 & \St{cmpi} & \Ss{RI} &

            Comparison with immediate operand \newline
            The value in the specified register is compared to the immediate operand \newline
            and the result is stored to the \St{flags} register \newline
            \St{cmpi r0, 0} \\

            \hline

            45 & \St{cmpd} & \Ss{RR} &

            Real-valued registers comparison \newline
            For real value storage and immediate operand comments \hyperlink{addd}{\St{addd}} \newline
            The floating-point value specified by the receiver register is compared to \newline
            the one specified by the source register and the result is stored \newline
            to the \St{flags} register \newline
            \St{cmpd r1, r4, 0} \newline
            In the example above the floating-point value stored in \St{(r1,r2)} is \newline
            compared to the one stored in \St{(r4,r5)} \\

            \hline

        \end{tabular}
    \end{table*}
}

\newpage

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table*}[h!]
        \centering
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

            \hline

            46 & \St{jmp} & \Ss{J} &

            Unconditional jump \newline
            The address of the next executed instruction is specified \newline
            by the immediate operand \newline
            \St{jmp 2212} \\

            \hline

            47 & \St{jne} & \Ss{J} &

            Jump if not equal \newline
            The jump only occurs if the \St{flags} register contains the `not equal' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jne 2212} \\

            \hline

            48 & \St{jeq} & \Ss{J} &

            Jump if equal \newline
            The jump only occurs if the \St{flags} register contains the `equal' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jeq 2212} \\

            \hline

            49 & \St{jle} & \Ss{J} &

            Jump if less or equal \newline
            The jump only occurs if the \St{flags} register contains the `less or equal' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jle 2212} \\

            \hline

            50 & \St{jl} & \Ss{J} &

            Jump if less \newline
            The jump only occurs if the \St{flags} register contains the `less' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jl 2212} \\

            \hline

            51 & \St{jge} & \Ss{J} &

            Jump if greater or equal \newline
            The jump only occurs if the \St{flags} register contains the `greater or equal' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jge 2212} \\

            \hline

            52 & \St{jg} & \Ss{J} &

            Jump if greater \newline
            The jump only occurs if the \St{flags} register contains the `greater' \newline
            condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
            The address of the next executed instruction in case the actual jump occurs \newline
            is specified by the immediate operand \newline
            \St{jg 2212} \\

            \hline

        \end{tabular}
    \end{table*}
}

\newpage

{
    \renewcommand{\arraystretch}{1.4}
    \begin{table*}[h!]
        \centering
        \vspace{2mm}
        \centering
        \begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

            \hline

            64 & \St{load} & \Ss{RM} &

            Load from memory to register \newline
            The value stored by the address specified by the immediate operand \newline
            is copied to the receiver register \newline
            \St{load r0, 12345} \\

            \hline

            65 & \St{store} & \Ss{RM} &

            Store from register to memory \newline
            The value stored in the source register is copied to the address \newline
            specified by the immediate operand \newline
            \St{store r0, 12344} \\

            \hline

            66 & \St{load2} & \Ss{RM} &

            Load two words from memory to registers \newline
            The value stored by the address specified by the immediate operand and \newline
            the next memory cell is copied to the receiver register and the next register \newline
            respectively \newline
            \St{load2 r0, 12345} \newline
            In the example above the values from the memory cells \St{12345} and \St{12346} \newline
            are copied to registers \St{r0} and \St{r1} respectively \\

            \hline

            67 & \St{store2} & \Ss{RM} &

            Store two words from registers to memory \newline
            The value stored in the source register and the next register are copied to \newline
            the address specified by the immediate operand and the next memory cell \newline
            respectively \newline
            \St{store2 r0, 12344} \newline
            In the example above the values from registers \St{r0} and \St{r1} are copied to \newline
            the memory cells \St{12344} and \St{12345} respectively \\

            \hline

            68 & \St{loadr} & \Ss{RR} &

            Load from memory to register \newline
            The value stored by the address which can be acquired by modifying the \newline
            source register by the immediate operand is copied to the receiver register \newline
            \St{loadr r0, r1, 15} \newline
            In the example above the value from the memory cell \St{r1+15} is copied to \St{r0} \\

            \hline

            69 & \St{storer} & \Ss{RR} &

            Store from register to memory \newline
            The value stored in the receiver register is copied to the address which can \newline
            be acquired by modifying the source register by the immediate operand \newline
            The naming of the argument registers for this command is counter-intuitive: \newline
            the value is copied \textit{from the receiver register} \newline
            \St{storer r0, r11, 3} \newline
            In the example above the value from \St{r0} is copied to the memory cell \St{r11+3} \\

            \hline

            70 & \St{loadr2} & \Ss{RR} &

            Load two words from memory to registers \newline
            The value stored by the address which can be acquired by modifying \newline
            the source register by the immediate operand and the next memory cell \newline
            is copied to the receiver register and the next register respectively \newline
            \St{loadr2 r0, r10, 12} \newline
            In the example above the values from the memory cells \St{r10+12} and \St{r10+13} \newline
            are copied to registers \St{r0} and \St{r1} respectively \\

            \hline

            71 & \St{storer2} & \Ss{RR} &

            Store two words from registers to memory \newline
            The value stored in the receiver register and the next register are copied to \newline
            the address which can be acquired by modifying the source register by \newline
            the immediate operand and the next memory cell respectively \newline
            The naming of the argument registers for this command is counter-intuitive: \newline
            the value is copied \textit{from the receiver register} \newline
            \St{storer2 r0, r3, 10} \newline
            In the example above the values from registers \St{r0} and \St{r1} are copied to \newline
            the memory cells \St{r3+10} and \St{r3+11} respectively \\

            \hline

        \end{tabular}
    \end{table*}
}

\newpage

\subsection{Further specifications}

\hypertarget{float:storage}{}

\subsubsection{Floating-point values}

Floating-point values are represented in base-2 scientific notation, i.e.\ in the form $m\cdot 2^n$, \newline
where $m\in [1, 2)$ is called a \textit{mantissa} and $n\in \mathbb{Z}$ -- an \textit{exponent}.

In memory they have a 64-bit representation.
The meaning of those bits (high to low) is as follows:

\begin{itemize}
    \item 1 bit -- sign (0 means $+$, 1 means $-$)
    \item 11 bits -- the exponent incremented by 1023
    \item 52 bits -- the fractional part of the mantissa
\end{itemize}

\hypertarget{syscall:details}{}

\subsubsection{System calls}

The \hyperlink{syscall}{\St{syscall}} operation has an immediate operand which specifies the call code.
The semantics of those codes is described in \hyperlink{syscall:codes}{Table 3}.

\hypertarget{syscall:codes}{}
{
    \renewcommand{\arraystretch}{1.4}
    \begin{table}[h!]
        \centering
        \caption{System call codes}
        \vspace{2mm}
        \begin{tabular}{| c | c | c | c |}
            \hline
            Code & Name             & Description                                           & Register operand  \\
            \hline
            0    & \St{EXIT}        & Finish execution without error                        & --                \\
            100  & \St{SCANINT}     & Get an integer value from \St{stdin}                  & Receiver          \\
            101  & \St{SCANDOUBLE}  & Get a floating-point value from \St{stdin}            & Low-bits receiver \\
            102  & \St{PRINTINT}    & Output an integer value to \St{stdout}                & Source            \\
            103  & \St{PRINTDOUBLE} & Output a floating-point value to \St{stdout}          & Low-bits source   \\
            104  & \St{GETCHAR}     & Get a single \St{ASCII} character from \St{stdin}     & Receiver          \\
            105  & \St{PUTCHAR}     & Output a single \St{ASCII} character from \St{stdout} & Source            \\
            \hline
        \end{tabular}
    \end{table}
}

Notes:

\begin{itemize}
    \item The floating-point value storage convention is the same as for the \hyperlink{addd}{\St{addd}} command, i.e.\ the specified register holds the lower bits of the value, and the next register holds the higher bits.
    \item If the register provided for the \St{PUTCHAR} system call holds a value greater than 255, an error occurs
    \item If the \St{syscall} command receives an unknown code, an error occurs
\end{itemize}

\hypertarget{flags:details}{}

\subsubsection{Flags}

To allow for basic execution branching, an additional \St{flags} register is supported.
It holds the result of the latest comparison.
Only the lowest 6 bits of this register are used.
The semantics of those bits is described in \hyperlink{flags:bits}{Table 4}.

\hypertarget{flags:bits}{}
{
    \renewcommand{\arraystretch}{1.4}
    \begin{table}[h!]
        \centering
        \caption{\St{flags} register bits semantics (counting from the lowest, 0-indexed)}
        \vspace{2mm}
        \begin{tabular}{| c | c |}
            \hline
            0 & Equal            \\
            1 & Not equal        \\
            2 & Greater          \\
            3 & Less             \\
            4 & Greater or equal \\
            5 & Less or equal    \\
            \hline
        \end{tabular}
    \end{table}
}

Several bits may be simultaneously filled.
For example, if the latest comparison resulted in equality, the value of the \St{flags} register will be $110001_2$, because equality causes the `less/greater or equal' conditions to also be true.

\subsubsection{Labels}

Either before a command or on a separate line one may place a \textit{label}, i.e.\ a word consisting of latin letters and/or numbers and not starting with a number.
It can be used later on in the assembler code to indicate the address of the command it is placed before.

Notes:

\begin{itemize}
    \item A label must be followed by a colon
    \item A use of an undefined label causes an error making it impossible to create an executable file from the assembler script
    \item One can use a label defined later on in the code
    \item The labels must be unique, i.e.\ they must not repeat or conflict with predefined words
\end{itemize}

\subsubsection{\St{End} directive}

An assembler program must have \textit{exactly one} \St{end} directive, which must be in \textit{the last} line of the program.
It has one operand which indicates the address of the first instruction (or a label).

\subsubsection{Comments}

Each line may contain a semicolon.
If it does, everything after the semicolon is considered a comment and is not compiled into the executable file.
Multiline comments are not allowed.

\vspace{.4in}

\subsection{Notes}

\begin{itemize}
    \item The \St{Karma} processor has a RISC architecture, which means that there is no way to operate directly on memory cells, all data has to be loaded to the registers before modifications and the results have to be explicitly stored back to the memory if necessary
    \item A function call does not include the function arguments.
          They can be passed either via the stack or via the registers (by a programmer-defined convention).
          However, if a function is directly or indirectly recursive, the best practice is to pass the arguments via the stack
    \item A Von Neumann architecture of the \St{Karma} computer implies that both the machine code of the program and the stack are inside the global address space.
          The machine code is placed at its beginning, while the stack starts at its end and grows `backwards'
    \item The stack does not have any size limits besides the address space size
    \item Our system allows to write data to any memory cells, including the ones occupied by the machine code itself.
          Therefore, theoretically, a program might overwrite itself during runtime, although such behaviour is not considered a good practice
\end{itemize}
