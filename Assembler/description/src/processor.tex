\section{\St{Karma} assembler standard}

\input{format}
\newpage

\input{commands}
\newpage

\subsection{Further specifications}

\hypertarget{float:storage}{}

\subsubsection{Floating-point values}

Floating-point values are represented in base-2 scientific notation, i.e.\ in the form $m\cdot 2^n$, \newline
where $m\in [1, 2)$ is called a \textit{mantissa} and $n\in \mathbb{Z}$ -- an \textit{exponent}.

In memory they have a 64-bit representation.
The meaning of those bits (high to low) is as follows:

\begin{itemize}
    \item 1 bit -- sign (0 means $+$, 1 means $-$)
    \item 11 bits -- the exponent incremented by 1023
    \item 52 bits -- the fractional part of the mantissa
\end{itemize}

\hypertarget{syscall:details}{}

\subsubsection{System calls}

The \hyperlink{syscall}{\St{syscall}} operation has an immediate operand which specifies the call code.
The semantics of those codes is described in \hyperlink{syscall:codes}{Table 3}.

\hypertarget{syscall:codes}{}
{
    \renewcommand{\arraystretch}{1.4}
    \begin{table}[h!]
        \centering
        \caption{System call codes}
        \vspace{2mm}
        \begin{tabular}{| c | c | c | c |}
            \hline
            Code & Name             & Description                                           & Register operand  \\
            \hline
            0    & \St{EXIT}        & Finish execution without error                        & --                \\
            100  & \St{SCANINT}     & Get an integer value from \St{stdin}                  & Receiver          \\
            101  & \St{SCANDOUBLE}  & Get a floating-point value from \St{stdin}            & Low-bits receiver \\
            102  & \St{PRINTINT}    & Output an integer value to \St{stdout}                & Source            \\
            103  & \St{PRINTDOUBLE} & Output a floating-point value to \St{stdout}          & Low-bits source   \\
            104  & \St{GETCHAR}     & Get a single \St{ASCII} character from \St{stdin}     & Receiver          \\
            105  & \St{PUTCHAR}     & Output a single \St{ASCII} character from \St{stdout} & Source            \\
            \hline
        \end{tabular}
    \end{table}
}

Notes:

\begin{itemize}
    \item The floating-point value storage convention is the same as for the \hyperlink{addd}{\St{addd}} command, i.e.\ the specified register holds the lower bits of the value, and the next register holds the higher bits.
    \item If the register provided for the \St{PUTCHAR} system call holds a value greater than 255, an error occurs
    \item If the \St{syscall} command receives an unknown code, an error occurs
\end{itemize}

\hypertarget{flags:details}{}

\subsubsection{Flags}

To allow for basic execution branching, an additional \St{flags} register is supported.
It holds the result of the latest comparison.
Only the lowest 6 bits of this register are used.
The semantics of those bits is described in \hyperlink{flags:bits}{Table 4}.

\hypertarget{flags:bits}{}
{
    \renewcommand{\arraystretch}{1.4}
    \begin{table}[h!]
        \centering
        \caption{\St{flags} register bits semantics (counting from the lowest, 0-indexed)}
        \vspace{2mm}
        \begin{tabular}{| c | c |}
            \hline
            0 & Equal            \\
            1 & Not equal        \\
            2 & Greater          \\
            3 & Less             \\
            4 & Greater or equal \\
            5 & Less or equal    \\
            \hline
        \end{tabular}
    \end{table}
}

Several bits may be simultaneously filled.
For example, if the latest comparison resulted in equality, the value of the \St{flags} register will be $110001_2$, because equality causes the `less/greater or equal' conditions to also be true.

\subsubsection{Labels}

Either before a command or on a separate line one may place a \textit{label}, which can be used later on in the assembler code to indicate the address of the command it is placed before.

Syntax:

\begin{itemize}
	\item A label must consist only of lowercase latin letters and/or digits and not start with a digit
	\item A label must be followed by a colon
    \item A label must be the first word in its line (it may be the only word of the line)
    \item A label must not conflict with predefined words (i.e.\ command names, directives, etc.)
	\item The labels must be unique (i.e. label redefinition is not allowed)
\end{itemize}

Usage:

\begin{itemize}
	\item A label usage may precede its definition
    \item A label must be defined somewhere in the code to be used, there are no predefined labels
    \item A label may only be used as a memory address, i.e.\ only in command of either \Ss{RM} or \Ss{J} type\\
    Note: this means that, when used, a label is always the last word in its line (see \hyperlink{command:formats}{command formats})
\end{itemize}

\subsubsection{\St{End} directive}

An assembler program must have \textit{exactly one} \St{end} directive, which must be in \textit{the last} line of the program.
It has one operand which indicates the address of the first instruction (or a label).

\subsubsection{Comments}

Each line may contain a semicolon.
If it does, everything after the semicolon is considered a comment and is not compiled into the executable file.
Multiline comments are not allowed.

\vspace{.4in}

\subsection{Notes}

\begin{itemize}
    \item The \St{Karma} processor has a RISC architecture, which means that there is no way to operate directly on memory cells, all data has to be loaded to the registers before modifications and the results have to be explicitly stored back to the memory if necessary
    \item A function call does not include the function arguments.
          They can be passed either via the stack or via the registers (by a programmer-defined convention).
          However, if a function is directly or indirectly recursive, the best practice is to pass the arguments via the stack
    \item A Von Neumann architecture of the \St{Karma} computer implies that both the machine code of the program and the stack are inside the global address space.
          The machine code is placed at its beginning, while the stack starts at its end and grows `backwards'
    \item The stack does not have any size limits besides the address space size
    \item Our system allows to write data to any memory cells, including the ones occupied by the machine code itself.
          Therefore, theoretically, a program might overwrite itself during runtime, although such behaviour is not considered a good practice
\end{itemize}
