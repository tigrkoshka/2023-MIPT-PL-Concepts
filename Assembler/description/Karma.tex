\documentclass{article}

\usepackage{titlesec}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{array}
\usepackage{amsfonts}
\usepackage{amsmath}

\hypersetup{colorlinks=true, linkcolor=magenta}

\newcommand{\St}[1]{{\fontfamily{qcr}\selectfont #1}}
\newcommand{\Ss}[1]{{\fontfamily{cmss}\selectfont #1}}


\title{\St{Karma} Computer}
\author{Tigran Koshkelian}
\date{ }

%--------------------Make usable space all of page
\titlespacing*{\section}{0pt}{0pt}{0pt}
\titlespacing*{\subsection}{0pt}{0pt}{0pt}
\setlength{\oddsidemargin}{0.2in}
\setlength{\evensidemargin}{0.2in}
\setlength{\topmargin}{-.4in}
\setlength{\headsep}{-.5in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{10.2in}
%--------------------

\begin{document}

\maketitle

{
\hypersetup{hidelinks}
\tableofcontents
}

\newpage

\section{Architecture}

\St{Karma} is a computer with a Von Neumann architecture with an address space of $2^{20}$ words, each of which takes up 32 bits.

Each command takes up \textit{exactly one} word, 8 high bits of which specify the operation code and the use of the rest 24 bits is command-specific.

The processor has 16 one-word (32 bits each) registers \St{r0}-\St{r15}, as well as an additional \St{flags} register (also one-word). Their usage is described in \hyperlink{registers}{Table 1}.

\hypertarget{registers}{}
{
\renewcommand{\arraystretch}{1.4}
\begin{table}[h!]
\centering
\caption{Usage of \St{Karma} processor registers}
\vspace{2mm}
\begin{tabular}{| c | c |} 
 \hline
 \St{r0}-\St{r12} & Free usage \\ 
 \St{r13} & Call frame pointer \\
 \St{r14} & Stack pointer \\
 \St{r15} & Command counter \\
 \St{flags} & Comparison operation result \\
 \hline
\end{tabular}
\end{table}
}

With respect to the operation code each command may be of one of the following formats:

\begin{itemize}
  \item \Ss{RM} (register-memory):

  \begin{itemize}
  	\item 8 bits of operation code
  	\item 4 bits of register number (either source or receiver)
  	\item 20 bits of memory address (an unsigned number from $0$ to $2^{20} - 1$)
  \end{itemize}
  
  Example: \St{load r0, 12323}

  \item \Ss{RR} (register-register):
  
  \begin{itemize}
  	\item 8 bits of operation code
  	\item 4 bits of receiver register number
  	\item 4 bits of source register number
  	\item 16 bits of source modifier (a signed number from $-2^{15}$ to $2^{15}-1$)
  \end{itemize}
  
  Example: \St{mov r1, r2, -123}
  
  \item \Ss{RI} (register-immediate value):
  
  \begin{itemize}
  	\item 8 bits of operation code
  	\item 4 bits of receiver register number
  	\item 20 bits of immediate operand (a signed number from $-2^{19}$ to $2^{19}-1$)
  \end{itemize}
  
  Example: \St{ori r2, 64}
  
  \item \Ss{J} (jump):
  
  \begin{itemize}
  	\item 8 bits of operation code
  	\item 4 bits ignored
  	\item 20 bits of memory address (an unsigned number from $0$ to $2^{20} - 1$)
  \end{itemize}
  
  Example: \St{calli 3121}
  
\end{itemize}

For the sake of not overcomplicating matters all arguments of any command are required. If one does not need the source modifier in a command of the \Ss{RR} format, the immediate operand should be specified as 0.

\newpage

\section{\St{Karma} processor description}

\subsection{\St{Karma} processor command set}

{
\renewcommand{\arraystretch}{1.4}
\begin{table}[h!]
\centering
\caption{\St{Karma} processor commands description}
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |} 
 \hline
 
 Code & Name & Format & Description\\
 
 \hline
 
 0 & \St{halt} & \Ss{RI} &
 
 Stop processor \newline
 \St{halt r1 0} \\
 
 \hline
 
 \hypertarget{syscall}{} 1 & \St{syscall} & \Ss{RI} &
 
 System call (see \hyperlink{syscall:details}{here} for details) \newline
 \St{syscall r0, 100} \\
 
 \hline
 
 2 & \St{add} & \Ss{RR} & 
 
 Registers addition \newline 
 The value in the source register modified by the immediate operand \newline
 is added to the value in the receiver register \newline
 \St{add r1, r2, 3} \newline
 In the example above \St{r2+3} is added to \St{r1} \\
 
 \hline
 3 & \St{addi} & \Ss{RI} & 
 
 Immediate operand addition to register \newline
 The immediate operand is added to the value in the receiver register \newline
 \St{addi r4, 10} \\
 
 \hline
 
 4 & \St{sub} & \Ss{RR} &
 
 Registers subtraction \newline
 The value in the source register modified by the immediate operand \newline
 is subtracted from the value in the receiver register \newline
 \St{sub r3, r5, 5}
 \newline In the example above \St{r5+5} is subtracted from \St{r3} \\
 
 \hline
 
 5 & \St{subi} & \Ss{RI} &
 
 Immediate operand subtraction from register \newline
 The immediate operand is subtracted from the value in the receiver register \newline
 \St{subi r4, 1} \\
 
 \hline
 
 6 & \St{mul} & \Ss{RR} &
 
 Registers multiplication \newline
 The value in the receiver register is multiplied by the value in the source \newline
 register modified by the immediate operand \newline
 The result is placed in a pair of registers starting from the receiver \newline
 so that the receiver contains the lower 32 bits of the result \newline
 \St{mul r3, r10, 2} \newline
 In the example above \St{r3} is multiplied by \St{r10+2} and the result \newline
 is placed in \St{r3} (low 32 bits) and \St{r4} (high 32 bits) \\
 
 \hline
 
 7 & \St{muli} & \Ss{RI} &
 
 Register multiplication by immediate operand \newline
 The value in the receiver register is multiplied by the immediate operand \newline
 The result is placed in a pair of registers starting from the receiver \newline
 so that the receiver contains the lower 32 bits of the result \newline
 \St{muli r5, 100} \newline
 In the example above the low 32 bits of the result will be in \St{r5} \newline
 and the high 32 bits -- in \St{r6}\\
 
 \hline
 
 8 & \St{div} & \Ss{RR} &
 
 Registers division \newline
 The low 32 bits of the dividend are located in the receiver register, \newline
 the high 32 bits -- in the next register. The divisor is located in the source \newline
 register and is modified by the immediate operand \newline
 The quotient is placed in the receiver register (if it does not fit, a \lq division \newline
 by zero\rq{} runtime error occurs) and the remainder -- in the next register \newline
 \St{div r3, r10, 5} \newline
 After execution of the example above \St{r3} will contain the quotient of dividing \newline
 \St{(r3,r4)} by \St{r10+5} and \St{r4} will contain the remainder \\
 
 \hline
 
 9 & \St{divi} & \Ss{RI} &
 
 Register division by immediate operand \newline
 The dividend and the result locations are analogous to \St{div} operation \newline
 \St{divi r3, 10} \newline
 After execution of the example above \St{r3} will contain the quotient of dividing \newline
 \St{(r3,r4)} by \St{10} and \St{r4} will contain the remainder \\
 
 \hline
 
\end{tabular}
\end{table}
}

\newpage

{
\renewcommand{\arraystretch}{1.4}
\begin{table*}[h!]
\centering
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |} 
	
 \hline
 
 12 & \St{lc} & \Ss{RI} &
 
 Storing immediate operand to the register \newline
 Supplemental bitwise shift and addition commands are required for storing \newline
 constants greater than $2^{20} - 1$ \newline
 \St{lc r7, 123} \\
 
 \hline
 
 13 & \St{shl} & \Ss{RR} &
 
 Bitwise left-shift of the value in the receiver register by the value \newline
 in the source register modified by the immediate operand \newline
 \St{shl r1, r2, 1} \\
 
 \hline
 
 14 & \St{shli} & \Ss{RI} &
 
 Bitwise left-shift of the value in the receiver register by \newline
 the immediate operand \newline
 \St{shli r1, 2} \\
 
 \hline
 
 15 & \St{shr} & \Ss{RR} &
 
 Bitwise right-shift of the value in the receiver register by the value \newline
 in the source register modified by the immediate operand \newline
 \St{shr r1, r2, 1} \\
 
 \hline
 
 16 & \St{shri} & \Ss{RI} &
 
 Bitwise right-shift of the value in the receiver register by \newline
 the immediate operand \newline
 \St{shri r1, 2} \\
 
 \hline
 
 17 & \St{and} & \Ss{RR} &
 
 Bitwise \textbf{and} of the value in the receiver register by the value \newline
 in the source register modified by the immediate operand \newline
 \St{and r4, r6, 5} \\
 
 \hline
 
 18 & \St{andi} & \Ss{RI} &
 
 Bitwise \textbf{and} of the value in the receiver register by the immediate operand \newline
 \St{andi r5, 2} \\
 
 \hline
 
 19 & \St{or} & \Ss{RR} &
 
 Bitwise \textbf{or} of the value in the receiver register by the value \newline
 in the source register modified by the immediate operand \newline
 \St{or r3, r2, 2} \\
 
 \hline
 
 20 & \St{ori} & \Ss{RI} &
 
 Bitwise \textbf{or} of the value in the receiver register by the immediate operand \newline
 \St{ori r6, 100} \\
 
 \hline
 
 21 & \St{xor} & \Ss{RR} &
 
 Bitwise \textbf{xor} of the value in the receiver register by the value \newline
 in the source register modified by the immediate operand \newline
 \St{xor r1, r5, 0} \\
 
 \hline
 
 22 & \St{xori} & \Ss{RI} &
 
 Bitwise \textbf{xor} of the value in the receiver register by the immediate operand \newline
 \St{xori r1, 127} \\
 
 \hline
 
 23 & \St{not} & \Ss{RI} &
 
 Bitwise \textbf{not} of the value in the receiver register \newline
 The immediate value is ignored, but per our agreement must be present \newline 
 for the simplicity of the compiler \newline
 \St{not r1, 0} \\
 
 \hline
 
 24 & \St{mov} & \Ss{RR} &
 
 Forwarding the value in the source register modified by the immediate \newline
 operand to the receiver register \newline
 \St{mov r0, r3, 10} \newline
 After the execution of the example above \St{r3+10} is stored in \St{r0}\\
 
 \hline

\end{tabular}
\end{table*}
}

\newpage

{
\renewcommand{\arraystretch}{1.4}
\begin{table*}[h!]
\centering
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

 \hline
 
 \hypertarget{addd}{} 32 &  \St{addd} & \Ss{RR} &
 
 Real-valued registers addition \newline
 The floating-point values are stored in two registers, the provided registers \newline
 contain the lower bits of the values (see \hyperlink{float:storage}{here} for details) \newline
 The immediate operand modifies the lower bits of the floating-point \newline
 representation of the source value, not the value itself, \newline
 so it should be used with much caution \newline
 \St{addd r2, r5, 0} \newline
 In the example above a floating-point value stored in \St{(r5,r6})\newline
 is added to the one stored in \St{(r2,r3})\\
 
 \hline
 
 33 & \St{subd} & \Ss{RR} &
 
 Real-valued registers subtraction \newline
 For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
 \St{subd r1, r6, 0} \newline
 In the example above a floating-point value stored in \St{(r6,r7})\newline
 is subtracted from the one stored in \St{(r1,r2})\\
 
 \hline
 
 34 & \St{muld} & \Ss{RR} &
 
 Real-valued registers multiplication \newline
 For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
 \St{muld r0, r2, 0} \newline
 In the example above a floating-point value stored in \St{(r0,r1})\newline
 is multiplied by the one stored in \St{(r2,r3})\\
 
 \hline
 
 35 & \St{divd} & \Ss{RR} &
 
 Real-valued registers division \newline
 For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
 \St{divd r1, r3, 0} \newline
 In the example above a floating-point value stored in \St{(r1,r2})\newline
 is divided by the one stored in \St{(r3,r4})\\
 
 \hline
 
 36 & \St{itod} & \Ss{RR} &
 
 Integer to floating-point transformation \newline
 The value in the source register modified by the immediate operand \newline
 is interpreted as an integer, transformed to a floating-point value and \newline
 stored in two registers starting from the receiver so that the receiver \newline
 contains the lower bits of the result \newline
 \St{itod r2, r5, 5} \newline
 In the example above the floating-point representation of value \St{r5+5} \newline
 is stored to \St{(r2,r3)} with \St{r2} containing the low 32 bits of the result\\
 
 \hline
 
 37 & \St{itod} & \Ss{RR} &
 
 Floating-point to integer transformation \newline
 The real value is rounded down to the closest integer \newline
 For real value storage and immediate operand comments see \hyperlink{addd}{\St{addd}} \newline
 If the resulting value does not fit a register, an error occurs \newline
 \St{dtoi r2, r5, 0} \newline
 In the example above the floating-point value stored in \St{(r5,r6)} \newline
 is rounded down and stored in \St{r2} \\
 
 \hline

\end{tabular}
\end{table*}
}

\newpage

{
\renewcommand{\arraystretch}{1.4}
\begin{table*}[h!]
\centering
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

 \hline
 
 38 & \St{push} & \Ss{RI} &
 
 Push the value from the source register modified by the immediate operand \newline 
 to the stack (and then move the stack pointer) \newline
 \St{push r0, 255} \newline
 In the example above the value \St{r0+255} is stored to the address from \St{r14}, \newline
 after which the stack pointer (\St{r14}) is decremented by 1\\
 
 \hline
 
 39 & \St{pop} & \Ss{RI} &
 
 Pop the value from the stack and store it in the receiver register after \newline
 modifying by the immediate operand (after moving the stack pointer) \newline 
 \St{pop r3, 3} \newline
 In the example above the stack pointer (\St{r14}) is incremented by 1, \newline
 after which the value stored by the address from \St{r14} is incremented by \St{3} \newline
 and stored in \St{r3} \\
 
 \hline
 
 40 & \St{call} & \Ss{RR} &
 
 Call the function, the address of which can be acquired by modifying \newline
 the source register by the immediate operand \newline
 The address of the command following the current one is stored \newline
 in the receiver register \newline 
 \St{call r0, r5, 2} \newline
 In the example above the function stored by the address \St{r5+2} is called and \newline
 the address of the command following the current one is both pushed to the \newline
 stack (i.e. stored by the address from \St{r14} with a consequent decrement of \newline
 \St{r14}) and stored in \St{r0} \\
 
 \hline
 
 41 & \St{calli} & \Ss{J} &
 
 Call the function, the address of which is specified by the immediate operand \newline
 \St{calli 13323} \newline
 In the example above the function stored by the address \St{13323} is called \newline
 and the address of the command following the current one is pushed to \newline
 the stack (i.e. stored by the address from \St{r14} with a consequent \newline
 decrement of \St{r14})\\
 
 \hline
 
 42 & \St{ret} & \Ss{J} &
 
 Return from function to caller \newline
 The address of the next executed instruction is popped from the stack \newline
 The immediate operand specifies the number of additional words that should \newline
 be ejected from the stack (by simply incrementing the \St{r14} pointer), which \newline
 must equal the number of the function arguments \newline
 \St{ret 3} \newline
 In the example above the pointer from \St{r14} is incremented by 1, the next \newline
 executed instruction is acquired by the address from \St{r14}, after which \newline
 the pointer from \St{r14} is additionally incremented by 3 \\
 
 \hline
 
 43 & \St{cmp} & \Ss{RR} &
 
 Registers comparison \newline
 The value in the receiver register is compared to the value in the source \newline
 pointer modified by the immediate operand and the result is stored \newline
 to the \St{flags} register \newline
 \St{cmp r0, r1, 2} \newline
 In the example above \St{r0} is compared to \St{r1+2} \\
 
 \hline
 
 44 & \St{cmpi} & \Ss{RI} &
 
 Comparison with immediate operand \newline
 The value in the specified register is compared to the immediate operand \newline
 and the result is stored to the \St{flags} register \newline
 \St{cmpi r0, 0} \\
 
 \hline
 
 45 & \St{cmpd} & \Ss{RR} &
 
 Real-valued registers comparison \newline
 For real value storage and immediate operand comments \hyperlink{addd}{\St{addd}} \newline
 The floating-point value specified by the receiver register is compared to \newline
 the one specified by the source register and the result is stored \newline
 to the \St{flags} register \newline
 \St{cmpd r1, r4, 0} \newline
 In the example above the floating-point value stored in \St{(r1,r2)} is \newline
 compared to the one stored in \St{(r4,r5)} \\
 
 \hline

\end{tabular}
\end{table*}
}

\newpage

{
\renewcommand{\arraystretch}{1.4}
\begin{table*}[h!]
\centering
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

 \hline
 
 46 & \St{jmp} & \Ss{J} &
 
 Unconditional jump \newline
 The address of the next executed instruction is specified \newline
 by the immediate operand \newline
 \St{jmp 2212} \\
 
 \hline
 
 47 & \St{jne} & \Ss{J} &
 
 Jump if not equal \newline
 The jump only occurs if the \St{flags} register contains the \lq not equal\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jne 2212} \\
 
 \hline
 
 48 & \St{jeq} & \Ss{J} &
 
 Jump if equal \newline
 The jump only occurs if the \St{flags} register contains the \lq equal\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jeq 2212} \\
 
 \hline
 
 49 & \St{jle} & \Ss{J} &
 
 Jump if less or equal \newline
 The jump only occurs if the \St{flags} register contains the \lq less or equal\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jle 2212} \\
 
 \hline
 
 50 & \St{jl} & \Ss{J} &
 
 Jump if less \newline
 The jump only occurs if the \St{flags} register contains the \lq less\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jl 2212} \\
 
 \hline
 
 51 & \St{jge} & \Ss{J} &
 
 Jump if greater or equal \newline
 The jump only occurs if the \St{flags} register contains the \lq greater or equal\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jge 2212} \\
 
 \hline
 
 52 & \St{jg} & \Ss{J} &
 
 Jump if greater \newline
 The jump only occurs if the \St{flags} register contains the \lq greater\rq \newline
 condition, else the execution continues (see \hyperlink{flags:details}{here} for details) \newline
 The address of the next executed instruction in case the actual jump occurs \newline
 is specified by the immediate operand \newline
 \St{jg 2212} \\
 
 \hline

\end{tabular}
\end{table*}
}

\newpage

{
\renewcommand{\arraystretch}{1.4}
\begin{table*}[h!]
\centering
\vspace{2mm}
\centering
\begin{tabular}{| >{\centering\arraybackslash} m{1cm} | >{\centering\arraybackslash} m{1.4cm} | >{\centering\arraybackslash} m{1.2cm} | m{11.6cm} |}

 \hline
 
 64 & \St{load} & \Ss{RM} &
 
 Load from memory to register \newline
 The value stored by the address specified by the immediate operand \newline
 is copied to the receiver register \newline
 \St{load r0, 12345} \\
 
 \hline
 
 65 & \St{store} & \Ss{RM} &
 
 Store from register to memory \newline
 The value stored in the source register is copied to the address \newline
 specified by the immediate operand \newline
 \St{store r0, 12344} \\
 
 \hline
 
 66 & \St{load2} & \Ss{RM} &
 
 Load two words from memory to registers \newline
 The value stored by the address specified by the immediate operand and \newline
 the next memory cell is copied to the receiver register and the next register \newline
 respectively \newline
 \St{load2 r0, 12345} \newline
 In the example above the values from the memory cells \St{12345} and \St{12346} \newline
 are copied to registers \St{r0} and \St{r1} respectively \\
 
 \hline
 
 67 & \St{store2} & \Ss{RM} &
 
 Store two words from registers to memory \newline
 The value stored in the source register and the next register are copied to \newline
 the address specified by the immediate operand and the next memory cell \newline
 respectively \newline
 \St{store2 r0, 12344} \newline
 In the example above the values from registers \St{r0} and \St{r1} are copied to \newline
 the memory cells \St{12344} and \St{12345} respectively \\
 
 \hline
 
 68 & \St{loadr} & \Ss{RR} &
 
 Load from memory to register \newline
 The value stored by the address which can be acquired by modifying the \newline
 source register by the immediate operand is copied to the receiver register \newline
 \St{loadr r0, r1, 15} \newline
 In the example above the value from the memory cell \St{r1+15} is copied to \St{r0} \\
 
 \hline
 
 69 & \St{storer} & \Ss{RR} &
 
 Store from register to memory \newline
 The value stored in the receiver register is copied to the address which can \newline
 be acquired by modifying the source register by the immediate operand \newline
 The naming of the argument registers for this command is counter-intuitive: \newline
 the value is copied \textit{from the receiver register} \newline
 \St{storer r0, r11, 3} \newline
 In the example above the value from \St{r0} is copied to the memory cell \St{r11+3} \\
 
 \hline
 
 70 & \St{loadr2} & \Ss{RR} &
 
 Load two words from memory to registers \newline
 The value stored by the address which can be acquired by modifying \newline
 the source register by the immediate operand and the next memory cell \newline
 is copied to the receiver register and the next register respectively \newline
 \St{loadr2 r0, r10, 12} \newline
 In the example above the values from the memory cells \St{r10+12} and \St{r10+13} \newline
 are copied to registers \St{r0} and \St{r1} respectively \\
 
 \hline
 
 71 & \St{storer2} & \Ss{RR} &
 
 Store two words from registers to memory \newline
 The value stored in the receiver register and the next register are copied to \newline
 the address which can be acquired by modifying the source register by \newline
 the immediate operand and the next memory cell respectively \newline
 The naming of the argument registers for this command is counter-intuitive: \newline
 the value is copied \textit{from the receiver register} \newline
 \St{storer2 r0, r3, 10} \newline
 In the example above the values from registers \St{r0} and \St{r1} are copied to \newline
 the memory cells \St{r3+10} and \St{r3+11} respectively \\
 
 \hline

\end{tabular}
\end{table*}
}

\newpage

\subsection{Further specifications}

\hypertarget{float:storage}{}
\subsubsection{Floating-point values}

Floating-point values are represented in base-2 scientific notation, i.e. in the form $m\cdot 2^n$, \newline
where $m\in [1, 2)$ is called a \textit{mantissa} and $n\in \mathbb{Z}$ -- an \textit{exponent}.

In memory they have a 64-bit representation. The meaning of those bits (high to low) is as follows:

\begin{itemize}
	\item 1 bit -- sign (0 means $+$, 1 means $-$)
	\item 11 bits -- the exponent incremented by 1023
	\item 52 bits -- the fractional part of the mantissa
\end{itemize}

\hypertarget{syscall:details}{}
\subsubsection{System calls}

The \hyperlink{syscall}{\St{syscall}} operation has an immediate operand which specifies the call code. The semantics of those codes is described in \hyperlink{syscall:codes}{Table 3}.

\hypertarget{syscall:codes}{}
{
\renewcommand{\arraystretch}{1.4}
\begin{table}[h!]
\centering
\caption{System call codes}
\vspace{2mm}
\begin{tabular}{| c | c | c | c |}
 \hline
 Code & Name & Description & Register operand \\ 
 \hline
 0 & \St{EXIT} & Finish execution without error & -- \\
 100 & \St{SCANINT} & Get an integer value from \St{stdin} & Receiver \\
 101 & \St{SCANDOUBLE} & Get a floating-point value from \St{stdin} & Low-bits receiver \\
 102 & \St{PRINTINT} & Output an integer value to \St{stdout} & Source \\
 103 & \St{PRINTDOUBLE} & Output a floating-point value to \St{stdout} & Low-bits source \\
 104 & \St{GETCHAR} & Get a single \St{ASCII} character from \St{stdin} & Receiver \\
 105 & \St{PUTCHAR} & Output a single \St{ASCII} character from \St{stdout} & Source \\
 \hline
\end{tabular}
\end{table}
}

Notes:

\begin{itemize}
	\item The floating-point value storage convention is the same as for the \hyperlink{addd}{\St{addd}} command, i.e. the specified register holds the lower bits of the value, and the next register holds the higher bits.
	\item If the register provided for the \St{PUTCHAR} system call holds a value greater than 255, an error occurs
	\item If the \St{syscall} command receives an unknown code, an error occurs
\end{itemize}

\hypertarget{flags:details}{}
\subsubsection{Flags}

To allow for basic execution branching, an additional \St{flags} register is supported. It holds the result of the latest comparison. Only the lowest 6 bits of this register are used. The semantics of those bits is described in \hyperlink{flags:bits}{Table 4}.

\hypertarget{flags:bits}{}
{
\renewcommand{\arraystretch}{1.4}
\begin{table}[h!]
\centering
\caption{\St{flags} register bits semantics (counting from the lowest, 0-indexed)}
\vspace{2mm}
\begin{tabular}{| c | c |}
 \hline
 0 & Equal \\
 1 & Not equal \\
 2 & Greater \\
 3 & Less \\
 4 & Greater or equal \\
 5 & Less or equal \\
 \hline
\end{tabular}
\end{table}
}

Several bits may be simultaneously filled. For example, if the latest comparison resulted in equality, the value of the \St{flags} register will be $110001_2$, because equality causes the \lq less/greater or equal\rq{} conditions to also be true.

\subsubsection{Labels}

Before any command or on a separate line one may place a \textit{label}, i.e. a word consisting of latin letters and/or numbers and not starting with a number. It can be used later on in the assembler code to indicate the address of the command it is placed before. 

Notes:

\begin{itemize}
	\item A label must be followed by a colon
	\item A use of an undefined label causes an error making it impossible to create an executable file from the assembler script
	\item One can use a label defined later on in the code
	\item The labels must be unique, i.e. they must not repeat or conflict with predefined words
\end{itemize}

\subsubsection{\St{End} directive}

An assembler program must have \textit{exactly one} \St{end} directive, which must be in \textit{the last} line of the program. It has one operand which indicates the address of the first instruction (or a label).

\subsubsection{Comments}

Each line may contain a semicolon. If it does, everything after the semicolon is considered a comment and is not compiled into the executable file. Multiline comments are not allowed.

\vspace{.4in}

\subsection{Notes}

\begin{itemize}
    \item The \St{Karma} processor has a RISC architecture, which means that there is no way to operate directly on memory cells, all data has to be loaded to the registers before modifications and the results have to be explicitly stored back to the memory if necessary
    \item A function call does not include the function arguments. They can be passed either via the stack or via the registers (by a programmer-defined convention). However, if a function is directly or indirectly recursive, the best practice is to pass the arguments via the stack
    \item A Von Neumann architecture of the \St{Karma} computer implies that both the machine code of the program and the stack are inside the global address space. The machine code is placed at its beginning, while the stack starts at its end and grows \lq backwards\rq
    \item The stack does not have any size limits besides the address space size
    \item Our system allows to write data to any memory cells, including the ones occupied by the machine  code itself. Therefore, theoretically, a program might overwrite itself in runtime, although such behaviour is not considered a good practice
\end{itemize}

\newpage

\section{\St{Karma} executable file}

To run a program on a \St{Karma} computer one needs to generate an executable file which contains meta-information about the machine code and the code itself. The executable file is stored in a remote storage (e.g a hard drive or an SSD) as a byte sequence. The header of the executable file takes up exactly 512 bytes. The format of the executable file is described in \hyperlink{flags:bits}{Table 5}.

\hypertarget{executable:format}{}
{
\renewcommand{\arraystretch}{1.4}
\begin{table}[h!]
\centering
\caption{\St{Karma} executable file format}
\vspace{2mm}
\begin{tabular}{| c | c |}
 \hline
 Bytes & Contents \\
 \hline
 0..15 & \St{ASCII} string "ThisIsKarmaExec" \\
 16..19 & Program code size \\
 20..23 & Program constants size \\
 24..27 & Program data size \\
 28..31 & Address of the first instruction \\
 32..35 & Initial stack pointer value \\
 36..39 & ID of the target processor \\
 512.. & Code segment \\
 & Constants segment \\
 & Data segment \\
 \hline
\end{tabular}
\end{table}
}

Notes:

\begin{itemize}
	\item The \St{ASCII} string at the beginning of the executable file contains 15 explicit characters and an implicit \lq\textbackslash 0\rq{} at the end
	\item The code, constants and data segments are loaded into the virtual \St{Karma} computer starting from the first memory cell
	\item The execution of the program starts from the instruction the address of which is specified in the executable file header
	\item The header also specifies the initial stack head address
\end{itemize}

\newpage

\section{Code samples}

\subsection{Calculate the square of a number without functions}

{
\renewcommand{\baselinestretch}{0.5}
\renewcommand{\arraystretch}{2}

\selectfont

\begin{table*}[h!]
\begin{tabular}{ m{4.5cm}  m{11cm} }

\St{main:}                   &                                                                      \\
\qquad \St{syscall r0, 100}  & ; read an integer from \St{stdin} to \St{r0}                         \\
\qquad \St{mov r2, r0, 0}    & ; copy from \St{r0} to \St{r2}                                       \\
\qquad \St{mul r0, r2, 0}    & ; a pair of registers \St{(r0,r1)} contains the square               \\
\qquad \St{syscall r0, 102}  & ; print from \St{r0} to \St{stdout} (i.e. the lower bits)            \\
\qquad \St{lc r0, 10}        & ; store the constant 10 (\lq\textbackslash n\rq) to \St{r0}          \\
\qquad \St{syscall r0, 105}  & ; print \lq\textbackslash n\rq{} from \St{r0} to \St{stdout}         \\
\qquad \St{lc r0, 0}         & ; clear \St{r0}                                                      \\
\qquad \St{syscall r0, 0}    & ; exit the program with code \St{0}                                  \\
\qquad \St{end main}         & ; start execution from label main                                    \\

\end{tabular}	
\end{table*}
}

\subsection{Calculate the square of a number with functions}

{
\renewcommand{\baselinestretch}{0.5}
\renewcommand{\arraystretch}{2}

\selectfont

\begin{table*}[h!]
\begin{tabular}{ m{4.5cm}  m{11cm} }

\St{sqr:}                     & ; a function calculating the square with one argument on the stack   \\ 
\qquad \St{loadr r0, r14, 1}  & ; load the first (and only) argument to \St{r0}                      \\ 
\qquad \St{mov r2, r0, 0}     & ; copy from \St{r0} to \St{r2}                                       \\
\qquad \St{mul r0, r2, 0}     & ; a pair of registers \St{(r0,r1)} contains the square               \\
\qquad \St{ret 1}             & ; return from function and remove the argument from the stack        \\

&\\

\St{intout:}                  & ; a function printing its argument and \lq\textbackslash n\rq        \\
\qquad \St{load r0, r14, 1}   & ; load the first (and only) argument to \St{r0}                      \\
\qquad \St{syscall r0, 102}   & ; print \St{r0} to \St{stdout}                                       \\
\qquad \St{lc r0, 10}         & ; store the constant \St{10} (\lq\textbackslash n\rq) to \St{r0}     \\
\qquad \St{syscall r0, 105}   & ; print \lq\textbackslash n\rq{} from \St{r0} to \St{stdout}         \\
\qquad \St{ret 1}             & ; return from function and remove the argument from the stack        \\

&\\

\St{main:}                    &                                                                      \\
\qquad \St{syscall r0, 100}   & ; read an integer from \St{stdin} to \St{r0}                         \\
\qquad \St{push r0, 0}        & ; put \St{r0+0} to the stack as the \St{sqr} argument                \\
\qquad \St{calli sqr}         & ; call \St{sqr}, the function will put the result to \St{r0}         \\ 
\qquad \St{push r0, 0}        & ; prepare the result of \St{sqr} to be passed to \St{intout}         \\
\qquad \St{calli intout}      & ; call \St{intout} with the prepared argument                        \\
\qquad \St{lc r0, 0}          & ; clear \St{r0}                                                      \\
\qquad \St{syscall r0, 0}     & ; exit the program with code \St{0}                                  \\
\qquad \St{end main}          & ; start execution from label main                                    \\


\end{tabular}	
\end{table*}
}

\newpage

\subsection{Calculate the factorial of a number using recursion}

{
\renewcommand{\baselinestretch}{0.5}
\renewcommand{\arraystretch}{2}

\selectfont

\begin{table*}[h!]
\begin{tabular}{ m{4.5cm}  m{11cm} }

\St{fact:}                    & ; a recursive function calculating the factorial of its argument     \\ 
\qquad \St{loadr r0, r14, 1}  & ; load the first (and only) argument to \St{r0}                      \\ 
\qquad \St{cmpi r0, 1}        & ; compare \St{r0} to \St{1}                                          \\
\qquad \St{jg skip0}          & ; if the argument is greater that \St{1}, recurse                    \\
\qquad \St{lc r0, 1}          & ; else store \St{1} (the result for this case, $1! = 1$) to \St{r0}  \\
\qquad \St{ret 1}             & ; return from function and remove the argument from the stack        \\

&\\

\St{skip0:}                   & ; a supplemental function providing recursion                        \\
\qquad \St{push r0, 0}        & ; push the current value to the stack ($\star$)                      \\
\qquad \St{subi r0, 1}        & ; decrement the current value by \St{1}                              \\
\qquad \St{push r0, 0}        & ; push the decremented value to stack as the \St{fact} argument      \\
\qquad \St{calli fact}        & ; \St{r0} contains the result for the decremented value              \\
\qquad \St{pop r2, 0}         & ; pop the value stored during the ($\star$) push to \St{r2}          \\
\qquad \St{mul r0, r2, 0}     & ; multiply the result for the decremented value by the current value \\
\qquad \St{ret 1}             & ; return from function and remove the argument from the stack        \\

&\\

\St{main:}                    &                                                                      \\
\qquad \St{syscall r0, 100}   & ; read an integer from \St{stdin} to \St{r0}                         \\
\qquad \St{push r0, 0}        & ; put \St{r0+0} to the stack as the \St{fact} argument               \\
\qquad \St{calli fact}        & ; call \St{fact}, the function will put the result to \St{r0}        \\
\qquad \St{syscall r0, 102}   & ; print \St{r0} to \St{stdout}                                       \\ 
\qquad \St{lc r0, 10}         & ; store the constant \St{10} (\lq\textbackslash n\rq) to \St{r0}     \\
\qquad \St{syscall r0, 105}   & ; print \lq\textbackslash n\rq{} from \St{r0} to \St{stdout}         \\
\qquad \St{lc r0, 0}          & ; clear \St{r0}                                                      \\
\qquad \St{syscall r0, 0}     & ; exit the program with code \St{0}                                  \\
\qquad \St{end main}          & ; start execution from label main                                    \\


\end{tabular}	
\end{table*}
}


\end{document}
































