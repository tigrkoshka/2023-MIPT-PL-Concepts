\subsubsection{Stack operators and function calls}

\cmdtable{Stack operators and function calls}{
    38 & \St{push} & \Ss{RI} & \RIcmd{push}{r0}{255} & fff \\

%    Push the value from the source register modified by the immediate operand \newline
%    to the stack (and then move the stack pointer) \newline
%    \St{push r0, 255} \newline
%    In the example above the value \St{r0+255} is stored to the address from \St{r14}, \newline
%    after which the stack pointer (\St{r14}) is decremented by 1 

    \hline

    39 & \St{pop} & \Ss{RI} & \RIcmd{pop}{r3}{3} & fff \\

%    Pop the value from the stack and store it in the receiver register after \newline
%    modifying by the immediate operand (after moving the stack pointer) \newline
%    \St{pop r3, 3} \newline
%    In the example above the stack pointer (\St{r14}) is incremented by 1, \newline
%    after which the value stored by the address from \St{r14} is incremented by \St{3} \newline
%    and stored in \St{r3} & \\

    \hline

    40 & \St{call} & \Ss{RR} & \RRcmd{call}{r0}{r5}{2} & fff \\

%    Call the function, the address of which can be acquired by modifying \newline
%    the source register by the immediate operand \newline
%    The address of the command following the current one is stored \newline
%    in the receiver register \newline
%    \St{call r0, r5, 2} \newline
%    In the example above the function stored by the address \St{r5+2} is called and \newline
%    the address of the command following the current one is both pushed to the \newline
%    stack (i.e.\ stored by the address from \St{r14} with a consequent decrement of \newline
%    \St{r14}) and stored in \St{r0} & \\

    \hline

    41 & \St{calli} & \Ss{J} & \St{calli\kern 0.5em 21913} & fff \\

%    Call the function, the address of which is specified by the immediate operand \newline
%    \St{calli 13323} \newline
%    In the example above the function stored by the address \St{13323} is called \newline
%    and the address of the command following the current one is pushed to \newline
%    the stack (i.e.\ stored by the address from \St{r14} with a consequent \newline
%    decrement of \St{r14}) & \\

    \hline

    42 & \St{ret} & \Ss{J} & \St{ret\sppp 3} & fff \\

%    Return from function to caller \newline
%    The address of the next executed instruction is popped from the stack \newline
%    The immediate operand specifies the number of additional words that should \newline
%    be ejected from the stack (by simply incrementing the \St{r14} pointer) before \newline
%    popping the next executed instruction address (it must equal the number \newline
%    of the function arguments) \newline
%    \St{ret 3} \newline
%    In the example above the pointer from \St{r14} is incremented by $3 + 1 = 4$, \newline
%    after which the next executed instruction address is acquired by the address \newline
%    from \St{r14} & \\
}